---
title: 前端面试题目
date: 2021-4-28
description: 一些常问的前端面试题
---

<h2>1.为什么token放在sessionStorage而不是localStorage？</h2>

是因为local是永久化，除非用户清除local信息，否则永久存在。sessiosStorage（会话储存）是在当前窗口或者标签页才存在，如果关闭就清空。token只需要在特定网页中使用，所以配合session使用。

<h2>2.为什么使用token而不是cookie的sessionID</h2>

session弊端：1、每个用户都有不同session，存放在服务器的内存中，如果用户过多会让内存压力增大。2.CSRF跨站伪造请求攻击，安全性不稳定，cookie如果被截获很容易受到攻击。3.扩展性不强，多个服务器，虽然每个服务器都执行的是同样的业务逻辑，但是session数据是保存在内存中的（不是共享的），访问不同服务器可能结果不同。

token好处：1.不会保留数据，服务器压力不大2.无状态，可以多个服务器共享3.避免攻击4.避开同源策略

<h2>3.内存泄漏是什么情况？</h2>

内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。

- setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
- 闭包
- 控制台日志
- 循环（两个对象互相引用且彼此保留）

<h2>4.Vue 插槽</h2>

通常我们会在vue中将各种通用的功能单独拿出来进行封装，以便于后面复用，但是有时候需要复用的组件不是完美契合，这个时候就需要用到插槽，slot可以让用户拓展组件，更好的实现组件的复用。

插槽就是子组件中的提供给父组件使用的一个占位符，用<slot></slot> 表示，父组件可以在这个占位符中填充任何模板代码，如 HTML、组件等，填充的内容会替换子组件的<slot></slot>标签。

作用域插槽解决的问题：当父组件向子组件插槽传递模板内容时存在访问子组件数据的问题

<h2>5.数据类型</h2>

`undefined`、`null`、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）、symbol

<h2>6.说出三种减低页面加载时间的方法?</h2>

1、压缩css、js文件
 2、合并js、css文件，减少http请求
 3、外部js、css文件放在最底下
 4、减少dom操作，尽可能用变量替代不必要的dom操作

<h2>7.常用数组</h2>

1. forEach() 循环整个数组相当于for循环，带索引和值
2. concat() //合并多个数组，返回合并后的新数组，原数组没有变化。
3. filter() //返回一个新数组，包含通过callback函数测试的所有元素。
4. map() //返回新数组
5. every()和some() //every()和some()方法是数组的逻辑判定
6. findIndex()返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1
7. include()，判断数组是否包含给定的值，有返回true，没有返回false，第二个参数表示搜索的起始位置

<h2>8.原型链</h2>

**对象原型proto**__，每个对象都会有的属性，new出来的实例通过proto属性来指向原型对象。不是标准方法，Object.getPrototypeOf()是标准方法

**原型对象prototype**，每个构造函数都有prototype属性，是个对象，通过构造函数.prototype指向。

每一个构造函数都有prototype属性，指向另一个对象。这个prototype就是个对象，这个对象的所有属性方法，都会被构造函数所拥有的。

一般情况下我们的公共属性直接定义在构造函数里面，公共的方法我们放在原型对象里面。

__proto__对象原型和原型对象是等价的，只不过写在不同对象上，一个写在函数后，一个写在对象后。

<h2>9.面向对象概念</h2>

面向对象 是操作对象，把事务分解成一个个对象，然后对对象进行操作，有利于复用、维护、扩展。

这个事件中有哪些类和对象，这些类和对象有哪些属性和方法，然后再将对象联系起来。

面向过程就是分析这个事件，分析出解决问题的步骤，一步一步实现，使用的时候再一步步调用。 

<h2>10.类的继承</h2>

类：ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，通过类实例化一个具体的对象（**就是ES6升级版的构造函数，等同于ES5的构造函数**

```js
		//es6的class 类
        //1.创建类 class 创建一个明星类                                        
        class Star {
            //constructor方法式类的默认构造函数
            constructor(uname,sex){//形参等于创建一个空变量 var uname;var sex;没有值 是undefined
                this.uname=uname;
                this.sex=sex;
            }
        }
        //2.利用类创建对象 new
        var lb=new Star('梁博','男')
        console.log(lb.sex);
        var zx=new Star('周迅','女')
        console.log(zx.uname);
        //(1) 通过class 关键字创建类, 类名我们还是习惯性定义首字母大写
        //(2) 类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象
        //(3) constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数
        //(4) 生成实例 new 不能省略
        //(5) 最后注意语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function
		//(6) 多个函数之间不需要用逗号分隔
        //自动生成的constructor函数？ 自动生成为一个空函数 没有形参 没有意义
```

类的继承：extends 关键字

```js
 			class Father{
            constructor(){
                this.x=x;
                this.y=y;
            }
            sum(){
                console.log(this.x+this.y);
            }
            sing(song){
                console.log('唱'+song);
            }
            money(){
                console.log(100);
            }
        }
        class Son extends Father{
            //如果constructor都不写 则直接继承父级的constructor 如果自己写了constructor里面却没有写super 则会报错
            constructor(n,m){//形参不必跟父类相同 只是名字而已 里面的数值是相等的
                this.n=n;
                this.m=m;
                // 如果需要父类的属性 就需要用到super
                //如果像方法money中没有调用父类的属性 则不需要
                // super关键字(n,m)
                //可以访问和调用父类的构造函数
            }
        }
        var son=new Son(1,2);
       	son.sum()//3
        // son.sing('男孩');
        son.money()
```

注意：继承中，如果实例化输出一个方法，子类有就调用自己，子类没有就查找父类。

**super关键字**，可以访问和调用父类函数。

ES6 的继承机制，实质是先将父类实例对象的属性和方法，加到`this`上面**（所以必须先调用`super`方法），然后再用子类的构造函数修改`this`。**

```js
   			class Father{
               say(){
                   // console.log('我是父亲');
                   return '我是父亲';
               }
           }
           class Son extends Father{
               say(){
                   // console.log('我是儿子');
                   //调用父级属性 super.say()是返回值 如果父亲是log则是undefined 如果父亲用的是返回值 则返回返回值
                   console.log(super.say);//这是个方法 函数就是个对象 super为父级 调用自己的say函数
                   console.log(super.say()+'的儿子');
               }
           }
           var son =new Son();
           son.say()
```

注意：时刻注意this的指向问题,类里面的共有的属性和方法一定要加this使用.

(1).constructor中的this指向的是new出来的实例对象 

(2).自定义的方法,一般也指向的new出来的实例对象

(3).绑定事件之后this指向的就是触发事件的事件源

<h2>11.this指向</h2>

1. 普通函数 this指向window 
2. 对象.方法名() this指向对象
3. 立即调用函数 this指向window
4. 定时器函数 this指向window
5. 构造函数 this指向对象实例
6. 绑定事件函数调用 this指向绑定事件的调用者
7. 箭头函数 this指向父级作用域的this 与外层this保持一致

<h2>12.在字符串每个字符中添加空格</h2>

```js
var text = "JavaScript";
text = text.split("").join(" ");
console.log(text);
```

<h2>13.预检请求是什么？</h2>

OPTIONS 请求属于预检请求，当存在跨域并且属于复杂请求时，浏览器自动发送判断接口是否接受这个请求

简单请求：如果请求方法是GET POST HEADE 并且请求头中只包含基本的请求（如：Content-Type/Accept/Accept-Type/...)

复杂请求：不是简单就是复杂

<h2>14.promise相关</h2>

异常中断：用一个新的promise不改变状态来中止

异常穿透：在其中某个then中抛出一个错误，后面没有指定错误回调，会抛给服务器，或者被catch捕捉。

<h2>15.选择器权重</h2>

style内联为1000，id选择器为0100，类、伪类和属性选择器为0010，元素选择器和伪元素为0001，通配符、子选择器、相邻选择器如*>+为0000。如果使用!important则是最高级的

<h2>16.px em rem 区别</h2>

px(pixel)像素：绝对单位。像素 px 是相对于显示器屏幕分辨率而言的，是一个虚拟长度单位，是计算机系统的数字化图像长度单位，如果 px 要换算成物理长度，需要指定精度 DPI。

em:相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。它会继承父级元素的字体大小，因此并不是一个固定的值。

rem:CSS3 新增的一个相对单位（root em，根 em），使用 rem 为元素设定字体大小时，仍然是相对大小，但相对的只是 HTML根元素。

简单理解：**em相对于父元素，rem相对于根元素。**

<h2>17.闭包</h2>

变量根据作用域不同分为局部变量和全局变量。

1. 函数内部可以使用全局变量
2. 函数外部不可以使用局部变量（父亲不能访问儿子变量）
3. 当函数执行完毕，会销毁该作用域中的局部变量

闭包：**就是有权访问另一个作用域中变量的函数**

一个作用域访问另外一个函数内部变量，被访问的函数被称为闭包函数。

```js
let arr = [1,2,3,4,5,6,7,8,9]
let a = arr.filter(function(v){
    return v>=2 && v<=9
})
console.log(a)
let b = arr.filter(function(v){
    return v>=4 && v<=10
})
console.log(b)
// 可以看到上面两个函数效果一致，只不过传的值不同
// 利用闭包封装一个函数来优化冗余
function between(a,b){
    return function(v){
        return v>=a && v<=b
    }
}
console.log(arr.filter(between(2,5)))// [2,3,4,5]
// 这个function(v)是between的子函数，利用闭包特性可以不断访问父级函数的变量a,b。将这个function返回出去当做filter参数的回调函数，每次调用都会开辟一个新的环境
```

![image-20201107200208676](C:\Users\黑籍\AppData\Roaming\Typora\typora-user-images\image-20201107200208676.png)

**好处**：1.可以读取函数内部的变量2.让这些变量的值始终保存在内存中（私有化变量）

**为什么需要闭包**：需要在全局环境中访问内部变量

<h2>18.如何封装出一个块级作用域</h2>

```js
for(var i =1;i<5;i++){
    // 在外包装一个立即执行函数，每次传进一个i，里面的定时器需要1s后才执行所以保留父级作用域环境中的变量a。这样就模拟了一个块级作用域
    (function(a){
        setTimeout(function(){
            console.log(a)
        },1000)
    })(i)
}
```

https://www.bilibili.com/video/BV1YJ411R7ap?p=8

<h2>19.环境和作用域</h2>

全局环境不会被回收，因为有可能在控制台所使用

写在函数内，不可访问到，而且没有其他地方引用他们的话，当函数执行完，他们都会被回收。

函数作用域在调用完函数后且没有其他引用时就会销毁，下次再调用就是新开辟一个作用域。

<h2>20.如何解决内存泄漏</h2>

```js
function closure(){
    var Divs = document.getElementByTag('Div');
    var test = DivS.innerHTML;
    DivS.onclick = function () {
        console.log(test)
    };
    oDiv = null;
}
// 如果每次都存储这个对象会导致内存的无用浪费，所以只拿到需要的值后把对象清空，打印的时候打印这个值就好
```

<h2>21.箭头函数的好处</h2>

1、更简洁的语法 2、解决this指向问题，原生this指向调用者，箭头this指向定义时的对象（上一级作用域的this）

<h2>22.防抖和节流</h2>

<h3>防抖(debounce)</h3>

说明：当事件被触发后，延迟 `n` 秒后再执行回调，如果在这 `n` 秒内事件又被触发，则重新计时。

效果：频繁触发只会实现一次

应用场景：用户输入一连串数字时，，可以通过防抖策略，只在输入完后，才执行查询的请求，这样可以有效减少请求次数，节约请求资源；

<h3>节流</h3>

说明：可以减少一段时间内事件的触发频率。

应用场景：

1.  鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次；
2.  懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不必去浪费 CPU 资源；

<h3>节流阀的概念</h3>

高铁卫生间是否被占用，由红绿灯控制，红灯表示被占用，绿灯表示可使用。

假设每个人上卫生间都需要花费5分钟，则五分钟之内，被占用的卫生间无法被其他人使用。

上一个人使用完毕后，需要将红灯**重置**为绿灯，表示下一个人可以使用卫生间。

下一个人在上卫生间之前，需要**先判断控制灯**是否为绿色，来知晓能否上卫生间。

节流阀为空，表示可以执行下次操作；不为空，表示不能执行下次操作。

当前操作执行完，必须将节流阀**重置**为空，表示可以执行下次操作了。

每次执行操作前，必须**先判断节流阀是否为空

**区别：**

- **防抖**：如果事件被频繁触发，防抖能保证只有最后一次触发生效！前面 N 多次的触发都会被忽略！

- **节流**：如果事件被频繁触发，节流能够减少事件触发的频率，因此，节流是有选择性地执行一部分事件！

<h2>23.同源策略</h2>

同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"**协议+域名+端口**"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。

<h2>24.cookie</h2>

Cookie实际上是key-value格式呈现的。客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。

<h2>25.token的作用</h2>

token在计算机身份认证中是令牌（临时）的意思，在词法分析中是标记的意思。一般作为邀请、登录系统使用。维持登录状态

<h2>26.typeof与instanceof和Object.toString.call</h2>

typeof仅能区别基本类型，即数字，字符串，undefined，布尔，对象。对于数组这种来说，只会返回Object，不能区分开。

instanceof能检测数组函数和对象，不能检测Number,boolean,String

Object.prototype.toString.call可以检测所有数据类型

<h2>27.当在地址栏中输入内容回车时，浏览器干了啥？</h2>

浏览器进程中的UI线程会监听到用户的输入，并判断输入内容类型，如果是关键字，则会使用默认配置的搜索引擎来查询，如果是域名，则会交给网络线程处理，通过DNS解析获取IP地址，接着开始与服务器建立TCP连接获取数据，获取到数据后，浏览器的安全系统会检查是否存在安全问题，如果存在，则会提示用户，用户也可选择无视，继续访问，接着网络线程会通知UI线程准备完毕，然后UI线程会创建一个渲染器进程，并通过IPC管道把数据传递给渲染器进程来渲染页面，接着渲染器进程的主线程开始逐层深入解析HTML生成DOM Tree，在解析的过程中如果发现JS脚本，则会停止解析，执行JS脚本，接着继续解析HTML，DOM Tree生成后，接着解析样式，然后基于DOM Tree和样式生成Layout Tree（Layout Tree和DOMTree并不是一一对应的，比如：display: none的节点不在Layout Tree中，而::before、::after这种伪元素不在DOM Tree中），有了Layout Tree后，我们还需要知道以什么顺序绘制（paint），主线程会遍历Layout Tree创建绘制记录表，该表记录了绘制的顺序，确保在屏幕上显示正确的层级，接着遍历Layout Tree生成Layer Tree图层树，接着主线程将Layer Tree和绘制顺序信息传递给合成器线程，合成器线程按规则进行分图层，并将每个图层栅格化，由于一层可能像整个页面一样大，所以会拆分成若干个图块，然后将每个图块发送给栅格化线程处理，栅格化线程处理完后将他们存储在GPU内存中，合成器线程将按需收集这些图块信息（draw quads）生成一个合成器帧（Compositor Frame），接着通过IPC将合成器帧传回给浏览器进程，然后交给GPU渲染展示到屏幕上，用户就看到了页面内容，当后续页面再发生变化，都会生成一个新的合成器帧，再传到GPU进行渲染，当我们改变某个元素的尺寸位置属性时，会重新进行样式计算、布局、绘制以及后面的所有流程，这种行为我们称为重排，当我们改变某个元素的颜色属性时，不会重新触发布局，但还是会触发样式计算和绘制，这个就是重绘，重排和重绘都会占用主线程，JS也是运行在主线程上，所以就会出现抢占执行时间的问题，如果写了一个不断导致重排重绘的动画，浏览器则需要在每一帧都运行样式计算、布局和绘制的操作，我们知道当页面以每秒60帧的刷新率（1000/60≈每帧16ms）才不会让用户感觉到卡顿，如果在运行动画时还有大量的JS任务需要执行，当在一帧的时间内布局和绘制结束后如果还有剩余时间，JS就会拿到主线程的使用权，如果JS执行时间过长，在下一帧开始时还没有及时归还主线程，就会导致下一帧动画没有按时渲染，出现动画的卡顿，可以通过两种手段优化，第一种就是通过requestAnimationFrame()这个API来帮助我们解决，这个方法会在每一帧的剩余时间内调用，下一帧开始前暂停JS执行，归还主线程，通过API的回调，我们可以把JS任务分成一些更小的任务块，React最新的渲染引擎React Fiber就是用到了这个API来做了很多优化，第二种优化方法，由于分图层和栅格化的整个流程是不占用主线程的，只在合成器线程和栅格线程中运行，这就意味着它无需和JS抢夺主线程，我们刚才提到如果反复进行重排和重绘可能会导致掉帧，这是因为有可能JS执行阻塞了主线程，而CSS中有个动画属性叫transform，通过该属性实现的动画不会经过样式计算、布局和绘制，而是直接运行在合成器线程和栅格化线程中，所以不会受到主线程中JS执行的影响，更重要的是，节省了很多运算时间，一般位置变化，宽高变化等等，都可以使用transform来代替。

<h2>28.计算属性和watch和methods区别</h2>

计算属性有缓存，可以节省内存空间。

computed计算属性是用来声明式的描述一个值依赖了其它的值，为响应式依赖，当所依赖的值或者变量改变时，计算属性也会跟着改变；

watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法；

methods就像我们写的普通函数一样，需要我们主动去调用才会执行，不会返回结果，只是执行过程。

当我们在获取一个数据时需要对一个大的数组进行大量循环才能获取时，那我们选择计算属性，基于依赖进行缓存那将会节省大量的性能消耗。

应用场景：

watch适合处理的场景是，侦听一个数的变化，当该数据变化，来处理其他与之相关数据的变化**（该数据影响别的多个数据）**
computed适合处理的场景是，获得一个值或者结果，该结果受其他的依赖的影响。**（一个数据受多个数据影响）**

methods用的是也是最多的，一般的事件绑定，普通函数，请求数据方法都是在methods中处理。然后vue的生命周期函数就是在相应的或者合适的时机调用这些定义好的函数。

<h2>29.在v-model上怎么用Vuex中state的值？</h2>

运用计算属性

```js
<input v-model="message">
// ...
computed: {
    message: {
        get () {
            return this.$store.state.message
        },
        set (value) {
            this.$store.commit('updateMessage', value)
        }
    }
}
```

<h2>30.Vuex的好处</h2>

1、能够在vuex中集中管理共享的数据，易于开发和后期维护；
2、能够高效地实现组件之间的数据共享，提高开发效率；
3、存储在vuex的数据都是响应式的，能够实时保持数据与页面的同步；

<h2>31.null和undefined区别</h2>

**`null`表示没有对象，即该处不应该有值**

1） 作为函数的参数，表示该函数的参数不是对象

2） 作为对象原型链的终点

**`undefined`表示缺少值，即此处应该有值，但没有定义**

1）定义了形参，没有传实参，显示undefined

2）对象属性名不存在时，显示undefined

3）函数没有写返回值，即没有写return，拿到的是undefined

4）写了return，但没有赋值，拿到的是undefined

null和undefined转换成number数据类型

**`null` 默认转成 `0`**

**`undefined` 默认转成 `NaN`**

<h2>32.new 关键字干了什么？</h2>

1、在内存中创建一个空对象

2、将this指向这个对象

3、执行构造函数里的代码，给这个新对象添加属性和方法

4、返回这个新对象

<h2>33.SPA单页面理解</h2>

SPA（single-page application）在Web页面初始化加载相应的HTML、JavaScript和CSS。加载完成，SPA不会因为用户的操作进行页面的重新加载和跳转，取而代之的则是由路由机制实现HTML内容的变换，UI与用户的交互，避免页面的重新加载。

好处：用户体验好，内容的改变不许重新加载整个页面，避免重复渲染，相对服务器压力小。架构清晰，前后端职责分离，前端进行交互逻辑后面负责数据处理。

缺点：初次加载时耗时过多。由于单页面应用在一个页面中显示所有内容，所以不能使用浏览器的前进后退，所有页面切换需要自己建立堆栈。SEO难度较大，不利于SEO。

<h2>34.模块中的v-model</h2>

一个组件上的 `v-model` 默认会利用名为 `value` 的 prop 和名为 `input` 的事件，但是像单选框、复选框等类型的输入控件可能会将 `value` attribute 用于[不同的目的](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value)。`model` 选项可以用来避免这样的冲突

```js
Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  }
}
```

<h2>35.sync修饰符的作用</h2>

vue封装了 子组件要修改父组件传过来的动态值的语法糖，省去了父组件需要写的方法，但是子组件emit时要加上update

子组件触发事件时需要this.$emit(update:父传过来的属性)

父组件中不需要再监听事件及写个方法来修改这个值了。

<h2>36.v-for key的作用</h2>

当页面的数据发生变化时，Diff算法只会比较同一层级的节点：

**如果节点类型不同，直接干掉前面的节点，再创建并插入新的节点，不会再比较这个节点以后的子节点了。**

**如果节点类型相同，则会重新设置该节点的属性，从而实现节点的更新。**

![image-20201109100902969](C:\Users\黑籍\AppData\Roaming\Typora\typora-user-images\image-20201109100902969.png)

**key的作用主要是为了高效的更新虚拟DOM。**另外vue中在使用**相同标签名元素的过渡切换**时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。

<h2>37.keep-alive</h2>

Props:

- `include` - 字符串或正则表达式。只有名称匹配的组件会被缓存。
- `exclude` - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。
- `max` - 数字。最多可以缓存多少组件实例。

用法：`<keep-alive>` 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 `<transition>` 相似，`<keep-alive>` 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。

当组件在 `<keep-alive>` 内被切换，它的 `activated` 和 `deactivated` 这两个生命周期钩子函数将会被对应执行。

**遍历整个组件树，只要有就缓存**

<h2>38.vue ref有什么用</h2>

`ref` 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 `$refs` 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例

注意：ref本身是作为渲染结果被创建的，在初始渲染时不能访问它们，那时还不存在。`$refs`也不是响应式，所以无法进行数据绑定

<h2>39.怎么做首屏优化渲染</h2>

一般都是用服务端渲染，中间做一个node中间层，在请求页面时服务器直接把这个页面html在后端拼好，客户端只需要渲染。可以说是老大做的，自己看了一下但是没自己做过。

<h2>40.原生js实现继承</h2>

构造函数中写每一次new实例都会执行一遍里面代码，就会创建多少次函数，占用内存空间。所以方法一般都放在原型上，属性放在构造函数中。

我们创建两个构造函数，在子构造函数中调用父构造函数.call方法再把需要的参数传进，就可以实现属性的继承。

方法的继承，我们新建一个对象使用现在的对象赋值给新建对象的__proto__，使用Object.create()，新建一个对象并返回，这个对象原型指向其参数，所以我们将父构造函数的.prototype传进去就可以完成，最后再把this指向回子构造函数即可。

```js
function Animal(name,sex){
      this.name=name
      this.sex=sex
    }
function Dog(sex,name,age){
    // ----------------属性继承
      Animal.call(this,sex,name)
      this.age=age
    }
    Animal.prototype.eat=function(){
      console.log(this.name+'吃东西Ing');
    }
	//-----------------方法继承
    Dog.prototype=Object.create(Animal.prototype)
    Dog.prototype.constructor=Dog
```

<h2>41.e.target和e.currentTarget</h2>

e.target是触发事件的目标元素，e.currentTarget是绑定事件监听的元素

比如事件委托的ul和小li，给ul绑定事件进行事件委托，则ul是e.currentTarget，li是e.target

<h2>42.cookie的生命周期（如何失效）</h2>

服务器设置cookie时有一个expires，过期时间，在设置的某个时间点后该cookie就会失效。maxAge：最大失效时间，有效期，设置在多少后失效 

区别是：maxAge是相对值，相对服务器第一次请求时记录的时间

Expires是相对稳健的最后访问时间或者修改时间

基本属性：

<h2>43.http和http2的区别，http2的新特性</h2>

<h2>44.ajax</h2>

AJAX = 异步 JavaScript 和 XML。

AJAX 是一种用于创建快速动态网页的技术。

通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。

传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。

<h2>45.axios和ajax区别</h2>

**ajax:**传统 Ajax 指的是 XMLHttpRequest（XHR）， 最早出现的发送后端请求技术，隶属于原始js中，核心使用XMLHttpRequest对象，多个请求之间如果有先后关系的话，就会出现**回调地狱**。
 JQuery ajax 是对原生XHR的封装，除此以外还增添了对**JSONP**的支持。经过多年的更新维护，真的已经是非常的方便了，优点无需多言；如果是硬要举出几个缺点，那可能只有：
 1.本身是针对MVC的编程,不符合现在前端**MVVM**的浪潮
 2.基于原生的XHR开发，XHR本身的架构不清晰。
 3.JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）

**axios**:axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征：
 1.从浏览器中创建 XMLHttpRequest
 2.支持 Promise API
 3.客户端支持防止CSRF
 4.提供了一些并发请求的接口（重要，方便了很多的操作）
 5.从 node.js 创建 http 请求
 6.拦截请求和响应
 7.转换请求和响应数据
 8.取消请求
 9.自动转换JSON数据

防止CSRF:就是让你的每个请求都带一个从cookie中拿到的key, 根据浏览器同源策略，假冒的网站是拿不到你cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。

<h2>46.图片懒加载的原理</h2>

先将img标签的src链接设为同一张图片（比如空白图片），然后给img标签设置自定义属性（比如 data-src）,然后将真正的图片地址存储在data-src中，当JS监听到该图片元素进入可视窗口时，将自定义属性中的地址存储到src属性中。达到懒加载的效果。

**这样做能防止页面一次性向服务器发送大量请求，导致服务器响应面，页面卡顿崩溃等。**

<h2>47.重绘和重排</h2>

重排：当改变 DOM 元素位置或大小时，会导致浏览器重新生成渲染树，这个过程叫重排。

重绘：当重新生成渲染树后，就要将渲染树每个节点绘制到屏幕，这个过程叫重绘。不是所有的动作都会导致重排，例如改变字体颜色，只会导致重绘。记住，重排会导致重绘，重绘不会导致重排 。

<h2>48.rem适配</h2>

用postcss-pxtorem插件来将单位转化成rem，再用lib-flexible来设置rem基准值。

lib-flexible就是一行分为十份，每份大小就是当前设备大小除于10。这个是将fontsize配置为十分之一

postcss下载完成后，在根目录配置.postcssrc.js文件。这个是将单位转化为rem。但是不能写行内样式，否则不会转换

<h2>49.浅拷贝和深拷贝</h2>

https://juejin.im/post/6889327058158092302#heading-17

**浅拷贝：** 如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以修改新拷贝的对象会影响原对象。

**深拷贝：** 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。

实现深拷贝：

1.JSON.parse(JSON.stringify(xxx))

2.递归克隆

```js
function deepClone(target,cache = new Map()){
  if(cache.get(target)){
      return cache.get(target)
  }
  if(target instanceof Object){
      let dist ;
      if(target instanceof Array){
        // 拷贝数组
        dist = [];
      }else if(target instanceof Function){
        // 拷贝函数
        dist = function () {
          return target.call(this, ...arguments);
        };
      }else if(target instanceof RegExp){
        // 拷贝正则表达式
       dist = new RegExp(target.source,target.flags);
      }else if(target instanceof Date){
          dist = new Date(target);
      }else{
        // 拷贝普通对象
        dist = {};
      }
      // 将属性和拷贝后的值作为一个map
      cache.set(target, dist);
      for(let key in target){
          // 过滤掉原型身上的属性
        if (target.hasOwnProperty(key)) {
            dist[key] = deepClone(target[key], cache);
        }
      }
      return dist;
  }else{
      return target;
  }
}
```

<h2>50.let const var 区别和实现原理</h2>

区别：

1. var与let是可以声明变量，const不能声明变量，只能声明只读的常量。
2. var声明的变量不存在块级作用域，他在全局内有效。let与const的声明只在其所在的代码块中有效。
3. let/const不能在同一个作用域中声明相同变量/常量，var可以多次重复声明。
4. var存在[变量提升](https://www.jianshu.com/p/76ab117d63b6),所以var能先使用在声明，但是let const必须先声明再使用。
5. let/const存在暂时性死区。
6. const声明时必须初始化赋值，一旦声明，其声明赋值的值就不允许改变，更不可以重复声明。

原理：

- var:会直接在栈(**基础数据类型**)内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针。
- let:是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错。
- const:也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性。

<h2>51.mvvm</h2>

MVVM(Model-View-ViewModel), 源自于经典的 Model–View–Controller（MVC）模式。MVVM 的出现促进了 GUI 前端开发与后端业务逻辑的分离，极大地提高了前端开发效率。MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的最重要一环。

<h2>52.虚拟DOM</h2>

假设一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量。所以，用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在虚拟DOM上，操作内存中的JS对象的速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制。

<h2>53.http协议</h2>

超文本传输协议是一种应用层上的客户端/服务端模型的通信协议，由请求和响应构成，客户端发送请求给服务端，服务端返回响应给客户端，且是无状态的。

- 协议：规定了通信双方必须遵循的数据传输格式，这样通信双方按照约定的格式才能准备的通信
- 无状态：指两次连接通信之间没有任何关系，每次都是一个新的连接，服务端不会记录前后的请求信息。

传送的数据（html文档，图片，普通文本）是通过url定位的，url由协议scheme、用户密码(一般为匿名)、主机host、端口port、路径path、请求参数(params)、查询参数(query)、片段(fragment)。

<h3>协议内容</h3>

1、http请求

- 请求行：请求方法 路径和查询参数 协议(http)版本 换行符
- 请求头：包含额外的信息来帮助服务器如何响应比如Accept设置接收响应资源的类型
- 请求体：需要发送的数据内容

2、响应

- 状态行：协议版本 状态码 状态码描述
- 响应头：与请求头类似，包含额外的信息
- 响应体：返回的数据

<h3>请求方法</h3>

![](C:\Users\黑籍\Pictures\截图\v2-c4f7ae799ff53a3c8be008bff4af0589_r.jpg)

<h3>请求和响应常见通用头</h3>

![](C:\Users\黑籍\Pictures\截图\v2-33dcad1049814f985e523bb705b4fa68_r.jpg)

<h2>54.响应状态码</h2>

100-199 一般信息，服务器收到请求，需要请求者继续执行操作

200-299 成功响应，操作被成功接收并处理

300-399 重定向，需要进一步的操作以完成请求

400-499 客户端错误，请求包含语法错误或无法完成请求

500-599 服务端错误，服务器在处理请求的过程中发生了错误

常见的有：

201：该请求已成功，一般为post/put请求成功后返回的响应

400：请求有错误，参数错误或语义错误

401：unauthorized，身份验证失败，缺少这个头相关信息或者信息错误

403：拒绝执行，并把理由放在返回体中

404：请求失败，资源未存在

500：服务器不知道该如何处理

502：服务器得到一个错误的响应

<h2>55.简单请求和复杂请求</h2>

简单请求：

- 使用`GET、POST、HEAD`其中一种方法

- 只使用了如下的安全首部字段，不得人为设置其他首部字段

  - `Accept`

  - `Accept-Language`

  - `Content-Language`

  - ```
    Content-Type
    ```

    仅限以下三种

    - `text/plain`
    - `multipart/form-data`
    - `application/x-www-form-urlencoded`

  - HTML头部header field字段：`DPR、Download、Save-Data、Viewport-Width、WIdth`

- 请求中的任意`XMLHttpRequestUpload` 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问

- 请求中没有使用 ReadableStream 对象

<h2>56.https</h2>

（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：

- 1、TCP 三次同步握手
- 2、客户端验证服务器数字证书
- 3、DH 算法协商对称加密算法的密钥、hash 算法的密钥
- 4、SSL 安全加密隧道协商完成
- 5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。

<h3>http和https区别</h3>

- **HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。**
- 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。
- HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。
- http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
- HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。

https://www.runoob.com/w3cnote/http-vs-https.html

<h2>57.http2</h2>

1. 二进制传输
2. 多路复用
3. header压缩
4. server push

<h2>58.轮播图</h2>

<h3>swiper</h3>

1.导入插件

2.class都为swiper-xxx

3.初始化swiper。direction垂直切换选项、loop循环模式切换、pagination分页器、

<h3>手写</h3>

使用的是css只显示一张图片，其余隐藏。通过计算偏移量利用定时器实现自动播放，或通过手动点击事件切换图片。

<h2>59.虚拟DOM</h2>

1. 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中
2. 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异
3. 把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了

Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。

<h2>60.xss和csrf</h2>

XSS：跨站脚本攻击（Cross Site Script，XSS攻击），通常指黑客通过“HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。

XSS的本质是一种“HTML注入”，用户的数据被当成了HTML代码一部分来执行，从而产生了新的语义。



CSRF:CSRF（Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。

